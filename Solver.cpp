#include "mpi.h"
#include <iostream>
#include <cmath>
#include <fstream>
#include <dmumps_c.h>

//---------------Defining rhs expression---------------
double rhs_expression(double x, double y){
    return -4 * (1- pow(x, 2) - pow(y, 2)) * 1.0/exp(pow(x,2) + pow(y,2));
}

//---------------Defining left boundary-----------------
double left_bound(double y){
    return 1.0/exp(pow(y,2));
}

//---------------Defining right boundary----------------
double right_bound(double y){
    return 1.0/exp(1 + pow(y,2));
}

//---------------Defining top boundary------------------
double top_bound(double x){
    return 1.0/exp(4 + pow(x,2));
}

//---------------Defining lower boundary----------------
double lower_bound(double x){
    return 1.0/exp(pow(x,2));
}


int main (int argc, char** argv){
    int ierr, rank, size;
    int Nx=4, Ny=4;     //Nodes in x and y direction; Nx = Ny; if not then change row_per_process
    double xMin = 0.0; double xMax = 1.0; double yMin = 0.0; double yMax = 2.0;
    double delx = (xMax-xMin)/(double(Nx)-1.0);
    double dely = (yMax-yMin)/(double(Ny)-1.0);

    std::ofstream f0("details.txt");

    f0<<"delx"<<delx<<"\n";
    f0<<"dely"<<dely<<"\n";
    f0<<"diag"<<-2.0/pow(delx,2) - 2.0/pow(dely, 2)<<"\n";
    f0<<"just_after_diag"<<-1.0/pow(delx,2)<<"\n";
    f0<<"far from diagonal"<<-1.0/pow(dely,2)<<"\n";
    f0.close();

    ierr = MPI_Init(&argc, &argv);   //MPI Initialization
    ierr = MPI_Comm_rank(MPI_COMM_WORLD, &rank);
    ierr = MPI_Comm_size(MPI_COMM_WORLD, &size);


    //------Mesh Generation---------//
    double Mesh_x[Nx], Mesh_y[Ny];
    for(size_t i = 0; i < Nx; i++){
        Mesh_x[i] = xMin + i*delx;
    }
    for(size_t j = 0; j < Ny; j++){
        Mesh_y[j] = yMin + j*dely; 
    }

    // if(rank == 0){
    //     std::cout<<Mesh_x[3]<<"\n";
    //     std::cout<<Mesh_y[3]<<"\n";
    // }
    // fflush(stdout);

    // std::cout<<"\n"<<ierr<<"\n";

    MUMPS_INT n;
    MUMPS_INT8 S;
    DMUMPS_STRUC_C id;
    int* irn_per_rank;
    int* jcn_per_rank;
    double* a_per_rank;
    double* rhs_per_rank;
    int s;
    int recvcount[size];
    int displ[size];
    double rhs_expression(double x, double y);
    double left_bound(double y);
    double right_bound(double y);
    double top_bound(double x);
    double lower_bound(double x);


    //-------------Global a, irn, jcn---------------
    double* a;
    int* irn;
    int* jcn;
    double* rhs;        //Nx*Nx

    // if(rank == 1){
    //     std::cout<<"rank 1";
    // }

//--------Memory Allocation according to MUMPS-----------

    int rows_per_process = Nx/size;
    if (rank == 0 || rank == size-1){
        s = (Nx-2)*4 + 6;               //may get change if Nx != Ny
        irn_per_rank = new int[s];
        jcn_per_rank = new int[s];
        a_per_rank = new double[s];
        rhs_per_rank = new double[Nx];       //may get change if Nx != Ny
    }
    else{
        s = (Nx-2)*5 + 8;               //may get change if Nx != Ny
        irn_per_rank = new int[s];
        jcn_per_rank = new int[s];
        a_per_rank = new double[s];
        rhs_per_rank = new double[Nx];
    }

//------A Part of Matrix Generated by each rank----------

    int k = 3;
    for(size_t j = (rank*rows_per_process) + 1; j <= rows_per_process * (rank + 1) ; j++){         //j is index in y-direction
        if(rank == 0 || rank == size-1){
            //---------------irn_per_rank generation--------------
            irn_per_rank[0] = irn_per_rank[1] = irn_per_rank[2] = (rank * Nx) + 1;
            irn_per_rank[s-1] = irn_per_rank[s-2] = irn_per_rank[s-3] = (rank * Nx) + Nx;
            for(size_t i = 2; i < Nx; i++){
                irn_per_rank[k] = irn_per_rank[k+1] = irn_per_rank[k+2] = irn_per_rank[k+3] = (rank * Nx) + i;
                k += 4;
            }
            
            if (rank == 0){
                //---------------jcn_per_rank generation--------------
                jcn_per_rank[0] = 1; jcn_per_rank[1] = 2; jcn_per_rank[2] = Nx + 1;
                jcn_per_rank[s-1] = 2*Nx; jcn_per_rank[s-2] = Nx; jcn_per_rank[s-3] = Nx - 1;  
                for(size_t i = 3; i < s-3; i= i+4){
                    jcn_per_rank[i] = irn_per_rank[i] - 1;                                                        //wrong
                    jcn_per_rank[i+1] = irn_per_rank[i+1];
                    jcn_per_rank[i+2] = irn_per_rank[i+2] + 1;
                    jcn_per_rank[i+3] = irn_per_rank[i+3] + 4;
                }
                rhs_per_rank[0] = rhs_expression(Mesh_x[1],Mesh_y[1]) - left_bound(Mesh_y[0])/pow(delx, 2) - lower_bound(Mesh_x[0])/pow(dely, 2);
                rhs_per_rank[Nx-1] = rhs_expression(Mesh_x[Nx-2], Mesh_y[Nx-2]) - right_bound(Mesh_y[1])/pow(delx,2) - lower_bound(Mesh_x[Nx-1])/pow(dely,2);
                for(size_t i = 1; i < Nx-1; i++){
                    rhs_per_rank[i] = rhs_expression(Mesh_x[i+1], Mesh_y[i+1]) - lower_bound(Mesh_x[i+1])/pow(dely,2);
                }
            }
            else if (rank == size - 1){
                //---------------jcn_per_rank generation--------------
                jcn_per_rank[0] = ((rank - 1) * Nx) + 1; jcn_per_rank[1] = (rank * Nx) + 1; jcn_per_rank[2] = jcn_per_rank[1] + 1;
                jcn_per_rank[s-1] = (rank + 1) * Nx; jcn_per_rank[s-2] = jcn_per_rank[s-1] - 1; jcn_per_rank[s-3] = Nx * rank;  
                for(size_t i = 3; i < s-3; i= i+4){
                    jcn_per_rank[i] = irn_per_rank[i] - 4;                                                        //wrong
                    jcn_per_rank[i+1] = irn_per_rank[i+1] - 1;
                    jcn_per_rank[i+2] = irn_per_rank[i+2];
                    jcn_per_rank[i+3] = irn_per_rank[i+3] + 1;
                }
                
            }
        }
        else{
            k = 4;
            //---------------irn_per_rank generation----------------
            irn_per_rank[0] = irn_per_rank[1] = irn_per_rank[2] = irn_per_rank[3] = 1 + (Nx*rank);
            irn_per_rank[s-1] = irn_per_rank[s-2] = irn_per_rank[s-3] = irn_per_rank[s-4] = Nx + (Nx*rank);
            for(size_t i = 2; i < size; i++){
                irn_per_rank[k] = irn_per_rank[k+1] = irn_per_rank[k+2] = irn_per_rank[k+3] = irn_per_rank[k+4] = i + (Nx*rank);
                k += 5;
            }

            //---------------jcn_per_rank generation----------------
            jcn_per_rank[0] = 1 + (rank - 1)*Nx; jcn_per_rank[1] = Nx + 1 + (rank - 1)*Nx; jcn_per_rank[2] = Nx + 2 + (rank - 1)*Nx; jcn_per_rank[3] = (2*Nx) + 1 + (rank - 1)*Nx;
            jcn_per_rank[s-1] = 3*Nx + (rank - 1)*Nx; jcn_per_rank[s-2] = 2*Nx + (rank - 1)*Nx; jcn_per_rank[s-3] = (2*Nx) - 1 + (rank - 1)*Nx; jcn_per_rank[s-4] = Nx + (rank - 1)*Nx;  
            for(size_t i = 4; i < s-4; i= i+5){
                jcn_per_rank[i] = irn_per_rank[i] - 4;
                jcn_per_rank[i+1] = irn_per_rank[i+1] - 1;
                jcn_per_rank[i+2] = irn_per_rank[i+2];
                jcn_per_rank[i+3] = irn_per_rank[i+3] + 1;
                jcn_per_rank[i+4] = irn_per_rank[i+4] + 4;
            }

        }
        ierr = MPI_Barrier(MPI_COMM_WORLD);

        //---------------a_per_rank generation----------------------
        for(size_t i = 0; i < s; i++){
            if(irn_per_rank[i] - jcn_per_rank[i] == 0)
                a_per_rank[i] = -2.0/pow(delx,2) - 2.0/pow(dely,2);
            else if (irn_per_rank[i] - jcn_per_rank[i] == 1 || irn_per_rank[i] - jcn_per_rank[i] == -1)
                a_per_rank[i] = -1.0/pow(delx,2);
            else if (irn_per_rank[i] - jcn_per_rank[i] == -Nx || irn_per_rank[i] - jcn_per_rank[i] == Nx)
                a_per_rank[i] = -1.0/pow(dely,2);
        }
    }

    ierr = MPI_Gather(&s, 1, MPI_INT, recvcount, 1, MPI_INT, 0, MPI_COMM_WORLD);
    // std::ofstream f11("irn.txt");

    if (rank == 0){
        displ[0] = 0;
        for(size_t j = 1; j < size; j++){
            displ[j] = recvcount[j-1] + displ[j-1];
        }
        for(int j = 0; j < size; j++){
            std::cout<<displ[j]<<"\n";
        }
        fflush(stdout);
    }

    if(rank == 0){
        S = 0;
        for(size_t i = 0; i < size; i++){
            S = recvcount[i] + S;
        }
        a = new double[S];
        irn = new int[S];
        jcn = new int[S];
    }

    ierr = MPI_Gatherv(a_per_rank, s, MPI_DOUBLE, a, recvcount, displ, MPI_DOUBLE, 0, MPI_COMM_WORLD);
    ierr = MPI_Gatherv(irn_per_rank, s, MPI_INT, irn, recvcount, displ, MPI_INT, 0, MPI_COMM_WORLD);
    ierr = MPI_Gatherv(jcn_per_rank, s, MPI_INT, jcn, recvcount, displ, MPI_INT, 0, MPI_COMM_WORLD);
    

    // if(rank == 0){
    //     std::ofstream f11("a.txt");
    //     for(size_t i = 0; i < S; i++){
    //         f11<<jcn[i]<<"\n";
    //     }
    //     f11.close();
    // }

    MPI_Barrier(MPI_COMM_WORLD);
    delete[] irn_per_rank;
    // if(rank == 2){
    delete[] jcn_per_rank;
    delete[] a_per_rank;



    if(rank == 0){
        delete[] irn;
        delete[] jcn;
        delete[] a;
    }

    MPI_Finalize();
    return 0;
}