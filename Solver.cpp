#include <iostream>
#include <cmath>


int main (int argc, char** argv){
    int ierr, rank, size;
    int Nx=4, Ny=4;     //Nodes in x and y direction also Nx = Ny; if not then change row_per_process
    double xMin = 0.0, xMax = 1.0, yMin = 0.0, yMax = 2.0;
    double delx = (xMax-xMin)/double(Nx)-1, dely = (yMax-yMin)/double(Ny)-1;

    //------Mesh Generation---------//
    double Mesh_x[Nx], Mesh_y[Ny];
    for(size_t i = 0; i < Nx; i++){
        Mesh_x[i] = xMin + i*delx;
    }
    for(size_t j = 0; j < Ny; j++){
        Mesh_y[j] = yMin + j*dely; 
    }

    ierr = MPI_Init(&argc, &argv)   ;   //MPI Initialization
    ierr = MPI_Comm_rank(MPI_COMM_WORLD, &rank);
    ierr = MPI_Comm_size(MPI_COMM_WORLD, &size);


//--------Memory Allocation according to MUMPS-----------

    int rows_per_process = Nx/size;
    if (rank == 0 || rank == size-1){
        int s = (Nx-2)*4 + 6;               //may get change if Nx != Ny
        int* irn = (int*)malloc(s * sizeof(int));
        int* jcn = (int*)malloc(s * sizeof(int));
        double* a = (double*)malloc(s * sizeof(double));
    }
    else{
        int s = (Nx-2)*5 + 8;               //may get change if Nx != Ny
        int* irn = (int*)malloc(s * sizeof(int));
        int* jcn = (int*)malloc(s * sizeof(int));
        double* a = (double*)malloc(s * sizeof(double));
    }


//------A Part of Matrix Generated by each rank----------

    int k = 3;
    for(size_t j = (rank*rows_per_process) + 1; j <= rows_per_process * (rank + 1) ; j++){         //j is index in y-direction
        if(rank == 0 || rank == size-1){
            
            //---------------irn generation--------------
            irn[0] = irn[1] = irn[2] = 1 + (rank * Nx) - 1;
            irn[s-1] = irn[s-2] = irn[s-3] = Nx  + (rank - 1) * Nx;
            for(size_t i = 2; i < s-3; i++){                                                //wrong
                irn[k] = irn[k+1] = irn[k+2] = irn[k+3] = i;
                k += 4;
            }

            //---------------jcn generation--------------
            jcn[0] = 1; jcn[1] = 2; jcn[2] = Nx + 1;
            jcn[s-1] = 2*Nx; jcn[s-2] = (rank*Nx) - 1; jcn[s-3] = Nx - 1;  
            for(size_t i = 3; i < s-3; i= i+4){
                jcn[i] = irn[i] - 1;                                                        //wrong
                jcn[i+1] = irn[i+1];
                jcn[i+2] = irn[i+2] + 1;
                jcn[i+3] = irn[i+3] + 4;
            }
        }
        else{

            //---------------irn generation----------------
            irn[0] = irn[1] = irn[2] = irn[4] = 1 + (Nx*rank);
            irn[s-1] = irn[s-2] = irn[s-3] = Nx + (Nx*rank);
            for(size_t i = 2; i < s-3; i++){
                irn[k] = irn[k+1] = irn[k+2] = irn[k+3] = irn[k+4] = i + (Nx*rank);
                k += 5;
            }

            //---------------jcn generation----------------
            jcn[0] = 1 + (rank - 1)*Nx; jcn[1] = Nx + 1 + (rank - 1)*Nx; jcn[2] = Nx + 2 + (rank - 1)*Nx; jcn[3] = (2*Nx) + 1 + (rank - 1)*Nx;
            jcn[s-1] = 3*Nx + (rank - 1)*Nx; jcn[s-2] = 2*Nx + (rank - 1)*Nx; jcn[s-3] = (2*Nx) - 1 + (rank - 1)*Nx; jcn[s-4] = Nx + (rank - 1)*Nx;  
            for(size_t i = 4; i < s-3; i= i+5){
                jcn[i] = irn[i] - 4;
                jcn[i+1] = irn[i+1] - 1;
                jcn[i+2] = irn[i+2];
                jcn[i+3] = irn[i+3] + 1;
                jcn[i+4] = irn[i+4] + 4;
            }

        }
        ierr = MPI_Barrier(MPI_COMM_WORLD);

        //---------------a generation----------------------
        for(size_t i = 0; i < s; i++){
            if(irn[i] - jcn[i] == 0.0)
                a[i] = -2/pow(delx,2) - 2/pow(dely,2);
            else if (irn[i] - jcn[i] == 1.0 || irn[i] - jcn[i] == -1.0)
                a[i] = -1.0/pow(delx,2);
            else if (irn[i] - jcn[i] == -Nx || irn[i] - jcn[i] == Nx)
                a[i] = -1.0/pow(dely,2);
        }
    }
    

    




    return 0;
}